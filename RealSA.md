# RealSA
- **Source code** như sau:
    ```python
    from Crypto.Util.number import *

    from sage.all import *

    from decimal import *

    getcontext().prec = 1337

    m = int.from_bytes(open("flag", "rb").read(), "big")

    p = getPrime(1024)

    q = getPrime(1024)

    n = p * q

    e = 0x10001

    c = pow(m, e, n)

    k = Decimal(13 * p) / Decimal(37 * q)

    print(f"{n = }")

    print(f"{k = }")

    print(f"{c = }")

    # n = 17836315959849005845422913663414767117290475262210084622418539759689446526987983742651500754163602658702257438603344638391750819833709014484652708660912517485982576088329107650903579302135534346444527279395069706657542682545893504177489484878621091879201295227306042107538374526455876591399833571819123247023786020228360607799594672502655951840534378236130046255384167067161776621232261217694793553143425503847220013445117355362394757758134988247473606426051594142031253234833680135858089993033130033931424522824906259429530883731507010765394295893181162700003958569803358503992193879775739289254856625735853342656691

    # k = Decimal('0.35446461146963444739100675019102427357742992648252679674999337860249514861192798736714999768802138877188987392684434984434144197346204736005963436261945282663139698407968154340692664314828815899336950075608038792449489090135267728757601438063136872975188570457340429981256096772094559698810422884676267599207870407837622200963038727101881041482893243181001811673162760179737922603650432405683896302254608853145829174684136576632615125057461035561006166588616534081650626850782025114955080335366309301772569589757429270179660568900330573464408796713721197954022970442599587489433052980288173667649600013009228667427447792587021853498147264391918385888912849882116066995440393702466541549251997103552974697549782099608620829417323165099966257193351492516942787771855106373851382745426598388778335847224000662124245942956989214545858513358450753373387923120632015977747472238670285286237716130056230984986202065783225256225423691426735932011376256751926687386762108587816483740258699371757433615173305137434119292838712721416785355612250164642843800878962968768192098173866139532824196545174345900695673844077156572039278918984913397930317429787962557294721805738693054179811835717065028952910215615224680053236949692064119797385474426572790113251198730129280310478508674699026563792292928948060895646025882846864383863565586607209169223951')

    # c = 4673035924389272278475077726179721834196795767239453119170003013692946332412255268083504867136759422845861665483227559383954843143670952281969970077731089347972838420010231661960479713394051608043031384693412159099965328507230965509961198520502268922686515047278411684052852995138615616040668732298091594792133478881624324818221814267947449074861355947381041272802241830653539106368971391423458933624515377831472054507217929993173878266225197776099109251511985341724790608910932841987840837417562296646705505719209341249852963919620413828831930283409960629361329433160615299527749956602571547705926320519915041473366

    ```
- **Mô tả:** đây là một challenge **RSA** bình thường, bình thường ở chỗ nó cho **n**, **ct**, **e** rồi bắt tìm **flag**. Nhưng bất bình thường ở chỗ là **số** của Challenge này **quá lớn** hoặc **quá nhỏ** mà những hàm bình thường không tính được. Qua challenge này mình cũng học được một số **thư viện** và **hàm** khá là hay, mình sẽ giới thiệu sau.
- Đi vào phân tích source code:
    - Để mã hóa RSA thì ta cần có được **p** và **q**, thứ mà đề sẽ không bao giờ cho =))
    - Ta sẽ thử bỏ nó lên http://factordb.com để nó phân tích thành thừa số nguyên tố, tiếc là số quá bự, web cũng không giúp được. Hầu hết những challenge RSA mình từng giải sẽ cho **n** khá là vừa để mình có thể dùng tool để tách ra nhưng challenge này thì không.
![Screenshot 2024-03-18 151947](https://github.com/MrBanhMi/CTF-solved/assets/155632468/75d72999-b362-4a75-ac4d-45af0868a5b3)


    - Bỏ qua việc phân tích thừa nố nguyên tố thì đề đã cho chúng ta **n**, **e**, **c** và **k**. Ta sẽ chú ý vào **k** vì **k** được tính từ **p** và **q**, nghĩa là từ biểu thức tính **k** ta đã có được mối quan hệ giữa **q** và **p**.
    - Ta sẽ biến đổi để tính **p** hoặc **q** như sau:

        ![Screenshot 2024-03-18 151215](https://github.com/MrBanhMi/CTF-solved/assets/155632468/1fb7369c-86f4-42ce-8967-91cf34ef2661)

    - Vậy là chúng ta đã có được công thức để tính **q**, tính được **q** thì chúng ta sẽ lấy **n** chia cho **q** là có được **p**.
    - Nhưng ở bước này thì mình vấp cỏ khá nhiều, cụ thể như sau:

       ![Screenshot 2024-03-18 135401](https://github.com/MrBanhMi/CTF-solved/assets/155632468/7057ef20-4d4e-49f1-81f2-b645b0cbd396)

    - Code ở trên là code mình dùng để tính **q ^ 2** tức cái này:

        ![Screenshot 2024-03-18 152626](https://github.com/MrBanhMi/CTF-solved/assets/155632468/3cf0b011-2351-4ce5-896a-d6ef1e124eba)

    - Nhưng ra kết quả là: ![Screenshot 2024-03-18 135407](https://github.com/MrBanhMi/CTF-solved/assets/155632468/1b8c30d0-cb8a-44b7-b9ef-80fcba096981)

    - Đây là số **đã được rút gọn** vì python **không thể biểu diễn** được số này, điều đó có nghĩa rằng mình không thể dùng nó để tính căn bậc hai được vì để tính căn bậc hai cần **số nguyên**.
    - **Sai lầm** ở đây là mình **bỏ quên** một dòng lệnh vô cùng quan trọng trong source code là `getcontext().prec = 1337`
    
       ![Screenshot 2024-03-18 153055](https://github.com/MrBanhMi/CTF-solved/assets/155632468/3335fb7a-a964-4954-9e85-294afff268b8)

    
    - `getcontext().prec = 1337` là một câu lệnh rất quan trọng, nó lấy tối đa **1337** số nguyên mà không làm tròn, bây giờ khi mình thêm nó vào thì kết quả sẽ là một con số khủng long.

        ![Screenshot 2024-03-18 153654](https://github.com/MrBanhMi/CTF-solved/assets/155632468/a400dae6-5096-4fae-a58f-b07da9457774)

    - Mình rút kinh nghiệm là lần sau code trên source code luôn, khỏi bỏ mất code quan trọng =))
        
    - Vấn đề tiếp theo là **tính căn bậc hai** của số khổng lồ trên, lần này mình lại vấp cỏ tiếp. Mình ngây thơ tưởng rằng muốn tính căn bậc hai thì chỉ cần dùng hàm **pow(q1, 1/2)** hoặc **q1 ** 1/2**. Kết quả là nó báo lỗi vì **số quá lớn**.
  
      ![image](https://github.com/MrBanhMi/CTF-solved/assets/155632468/6dd39480-2b8d-45ad-afc2-7f15700fc5cf)

    - Bài học rút ra tiếp theo là sử dụng thư viện toán mạnh để tính căn bậc hai hoặc các phương trình phức tạp hơn.
    - Mình sẽ sử dụng thư viện **gmpy2** bằng câu lệnh `import gmpy2`. Để tính căn bậc hai thì mình sử dụng câu lệnh sau `q = gmpy2.iroot(q2, 2)[0]`
    - Kết quả sẽ là 
![Screenshot 2024-03-18 154908](https://github.com/MrBanhMi/CTF-solved/assets/155632468/0b9814d8-0b01-4bf0-a95a-81020426bf9d)

    - Giờ ta đã có được **q**, để tính được **p** thì ta chỉ đơn giản lấy **n** chia **q** thôi =)) nhưng không, mình lại vấp cỏ tiếp.

        ![Screenshot 2024-03-18 155408](https://github.com/MrBanhMi/CTF-solved/assets/155632468/32790731-ed6e-40c7-9011-5d87e988d5c7)

    - Kết quả là `1.3414305906813075e+308` =))

        ![Screenshot 2024-03-18 155615](https://github.com/MrBanhMi/CTF-solved/assets/155632468/743c4b91-534d-4cc2-9bad-a3e28816c001)


    - Nó **lại làm tròn** vì số khá là bự, mình nhớ là đã dùng `getcontext().prec = 1337` nhưng giờ nó vẫn làm tròn. Mình rút ra được bài học là thay vì dùng phép chia **/** thì nên dùng phép chia **//**, ta sửa lại thành `p = n // q` được kết quả:
    
        ![image](https://github.com/MrBanhMi/CTF-solved/assets/155632468/aaf5ff17-c6b2-4903-b5b3-8f04032a1d2e)



    - Sau bao nhiêu bão táp thì ta đã có được **p**, **q**, ta có thể dễ dàng giải được challenge này.
    - **Chú ý** là source code có dùng thư viện **Decimal**, thư viện này sẽ giúp bảo toàn giá trị của một số **Float** siêu nhỏ, vì khi python thấy một số **quá nhỏ** thì nó thường có xu hướng **làm tròn** số đó. Nhưng ở những bài toán cần sự chính xác cao thì ta nên dùng thư viện Decimal để python không làm tròn số siêu nhỏ đó:
        - k = 0.35446461146...51 là số siêu nhỏ nên dễ bị python làm tròn nên ta phải bỏ vào hàm Decimal('')

- Đoạn code sẽ như sau:
    ```python
    from Crypto.Util.number import *

    from decimal import *

    import gmpy2

    getcontext().prec = 1337 #cái này khá là quan trọng, giúp lấy 1337 số phía sau dấu phẩy

    n = 17836315959849005845422913663414767117290475262210084622418539759689446526987983742651500754163602658702257438603344638391750819833709014484652708660912517485982576088329107650903579302135534346444527279395069706657542682545893504177489484878621091879201295227306042107538374526455876591399833571819123247023786020228360607799594672502655951840534378236130046255384167067161776621232261217694793553143425503847220013445117355362394757758134988247473606426051594142031253234833680135858089993033130033931424522824906259429530883731507010765394295893181162700003958569803358503992193879775739289254856625735853342656691

    k = Decimal('0.35446461146963444739100675019102427357742992648252679674999337860249514861192798736714999768802138877188987392684434984434144197346204736005963436261945282663139698407968154340692664314828815899336950075608038792449489090135267728757601438063136872975188570457340429981256096772094559698810422884676267599207870407837622200963038727101881041482893243181001811673162760179737922603650432405683896302254608853145829174684136576632615125057461035561006166588616534081650626850782025114955080335366309301772569589757429270179660568900330573464408796713721197954022970442599587489433052980288173667649600013009228667427447792587021853498147264391918385888912849882116066995440393702466541549251997103552974697549782099608620829417323165099966257193351492516942787771855106373851382745426598388778335847224000662124245942956989214545858513358450753373387923120632015977747472238670285286237716130056230984986202065783225256225423691426735932011376256751926687386762108587816483740258699371757433615173305137434119292838712721416785355612250164642843800878962968768192098173866139532824196545174345900695673844077156572039278918984913397930317429787962557294721805738693054179811835717065028952910215615224680053236949692064119797385474426572790113251198730129280310478508674699026563792292928948060895646025882846864383863565586607209169223951')
    #kiểu dữ liệu float thường khá là lỗi do nó hay làm tròn nên ta sẽ dùng Decimal('') để giữ nguyên nó

    c = 4673035924389272278475077726179721834196795767239453119170003013692946332412255268083504867136759422845861665483227559383954843143670952281969970077731089347972838420010231661960479713394051608043031384693412159099965328507230965509961198520502268922686515047278411684052852995138615616040668732298091594792133478881624324818221814267947449074861355947381041272802241830653539106368971391423458933624515377831472054507217929993173878266225197776099109251511985341724790608910932841987840837417562296646705505719209341249852963919620413828831930283409960629361329433160615299527749956602571547705926320519915041473366

    e = 65537

    q2 = int((13*n)/(37*k))

    q = gmpy2.iroot(q2, 2)[0] #hàm tính căn promax

    p = n // q

    print(long_to_bytes(pow(c, pow(e, -1, (p-1)*(q-1)), n)))
    #kết quả sẽ là: b'W1{now_you_know_how_to_use_continued_fraction!}'
    ```
- Vậy flag của challenge này là: ***W1{now_you_know_how_to_use_continued_fraction!}***
    


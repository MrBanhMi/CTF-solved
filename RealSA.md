# RealSA
- **Source code** như sau:
    ```python!
    from Crypto.Util.number import *

    from sage.all import *

    from decimal import *

    getcontext().prec = 1337

    m = int.from_bytes(open("flag", "rb").read(), "big")

    p = getPrime(1024)

    q = getPrime(1024)

    n = p * q

    e = 0x10001

    c = pow(m, e, n)

    k = Decimal(13 * p) / Decimal(37 * q)

    print(f"{n = }")

    print(f"{k = }")

    print(f"{c = }")

    # n = 17836315959849005845422913663414767117290475262210084622418539759689446526987983742651500754163602658702257438603344638391750819833709014484652708660912517485982576088329107650903579302135534346444527279395069706657542682545893504177489484878621091879201295227306042107538374526455876591399833571819123247023786020228360607799594672502655951840534378236130046255384167067161776621232261217694793553143425503847220013445117355362394757758134988247473606426051594142031253234833680135858089993033130033931424522824906259429530883731507010765394295893181162700003958569803358503992193879775739289254856625735853342656691

    # k = Decimal('0.35446461146963444739100675019102427357742992648252679674999337860249514861192798736714999768802138877188987392684434984434144197346204736005963436261945282663139698407968154340692664314828815899336950075608038792449489090135267728757601438063136872975188570457340429981256096772094559698810422884676267599207870407837622200963038727101881041482893243181001811673162760179737922603650432405683896302254608853145829174684136576632615125057461035561006166588616534081650626850782025114955080335366309301772569589757429270179660568900330573464408796713721197954022970442599587489433052980288173667649600013009228667427447792587021853498147264391918385888912849882116066995440393702466541549251997103552974697549782099608620829417323165099966257193351492516942787771855106373851382745426598388778335847224000662124245942956989214545858513358450753373387923120632015977747472238670285286237716130056230984986202065783225256225423691426735932011376256751926687386762108587816483740258699371757433615173305137434119292838712721416785355612250164642843800878962968768192098173866139532824196545174345900695673844077156572039278918984913397930317429787962557294721805738693054179811835717065028952910215615224680053236949692064119797385474426572790113251198730129280310478508674699026563792292928948060895646025882846864383863565586607209169223951')

    # c = 4673035924389272278475077726179721834196795767239453119170003013692946332412255268083504867136759422845861665483227559383954843143670952281969970077731089347972838420010231661960479713394051608043031384693412159099965328507230965509961198520502268922686515047278411684052852995138615616040668732298091594792133478881624324818221814267947449074861355947381041272802241830653539106368971391423458933624515377831472054507217929993173878266225197776099109251511985341724790608910932841987840837417562296646705505719209341249852963919620413828831930283409960629361329433160615299527749956602571547705926320519915041473366

    ```
- **Mô tả:** đây là một challenge **RSA** bình thường, bình thường ở chỗ nó cho **n**, **ct**, **e** rồi bắt tìm **flag**. Nhưng bất bình thường ở chỗ là **số** của Challenge này **quá lớn** hoặc **quá nhỏ** mà những hàm bình thường không tính được. Qua challenge này mình cũng học được một số **thư viện** và **hàm** khá là hay, mình sẽ giới thiệu sau.
- Đi vào phân tích source code:
    - Để mã hóa RSA thì ta cần có được **p** và **q**, thứ mà đề sẽ không bao giờ cho =))
    - Ta sẽ thử bỏ nó lên http://factordb.com để nó phân tích thành thừa số nguyên tố, tiếc là số quá bự, web cũng không giúp được. Hầu hết những challenge RSA mình từng giải sẽ cho n khá là vừa để mình có thể dùng tool để tách ra nhưng challenge này thì không.
![image](https://hackmd.io/_uploads/SJJrt_BAp.png)

    - Bỏ qua việc phân tích thừa nố nguyên tố thì đề đã cho chúng ta **n**, **e**, **c** và **k**. Ta sẽ chú ý vào **k** vì **k** được tính từ **p** và **q**, nghĩa là từ biểu thức tính k ta đã có được mối quan hệ giữa q và p.
    - Ta sẽ biến đổi để tính **p** hoặc **q** như sau:

        ![image](https://hackmd.io/_uploads/BJtOw_r06.png)
    - Vậy là chúng ta đã có được công thức để tính **q**, tính được **q** thì chúng ta sẽ lấy **n** chia cho **q** là có được **p**.
    - Nhưng ở bước này thì mình vấp cỏ khá nhiều, cụ thể như sau:

        ![image](https://hackmd.io/_uploads/HJM9cuS0T.png)
    - Code ở trên là code mình dùng để tính q ^ 2 tức cái này:

        ![image](https://hackmd.io/_uploads/r1za9urRT.png)
    - Nhưng ra kết quả là: ![image](https://hackmd.io/_uploads/rkDMourAT.png)
    - Đây là số **đã được rút gọn** vì python **không thể biểu diễn** được số này, điều đó có nghĩa rằng mình không thể dùng nó để tính căn bậc hai được vì để tính căn bậc hai cần **số nguyên**.
    - **Sai lầm** ở đây là mình **bỏ quên** một dòng lệnh vô cùng quan trọng trong source code là `getcontext().prec = 1337`
    
        ![Screenshot 2024-03-18 153055](https://hackmd.io/_uploads/BJMXn_SAa.png)
    
    - `getcontext().prec = 1337` là một câu lệnh rất quan trọng, nó lấy tối đa 1337 số nguyên mà không làm tròn, bây giờ khi mình thêm nó vào thì kết quả sẽ là một con số khủng long.

        ![image](https://hackmd.io/_uploads/r1KVauBC6.png)
    - Mình rút kinh nghiệm là lần sau code trên source code luôn, khỏi bỏ mất code quan trọng =))
        
    - Vấn đề tiếp theo là **tính căn bậc hai** của số khổng lồ trên, lần này mình lại vấp cỏ tiếp. Mình ngây thơ tưởng rằng muốn tính căn bậc hai thì chỉ cần dùng hàm **pow(q1, 1/2)** hoặc **q1 ** 1/2**. Kết quả là nó báo lỗi vì **số quá lớn**.
    - Bài học rút ra tiếp theo là sử dụng thư viện toán cực mạnh để tính căn bậc hai.
    - Mình sẽ sử dụng thư viện **gmpy2** bằng câu lệnh `import gmpy2`. Để tính căn bậc hai thì mình sử dụng câu lệnh sau `q = gmpy2.iroot(q2, 2)[0]`
    - Kết quả sẽ là 
![image](https://hackmd.io/_uploads/HJUMxYBAp.png)
    - Giờ ta đã có được **q**, để tính được **p** thì ta chỉ đơn giản lấy **n** chia **q** thôi =)) nhưng không, mình lại vấp cỏ tiếp.

        ![image](https://hackmd.io/_uploads/rJQrbYSC6.png)
    - Kết quả là `1.3414305906813075e+308` =))

        ![image](https://hackmd.io/_uploads/SyDaWFSRa.png)

    - Nó **lại làm tròn** vì số khá là bự, mình nhớ là đã dùng `getcontext().prec = 1337` nhưng giờ nó vẫn làm tròn. Mình rút ra được bài học là thay vì dùng phép chia **/** thì nên dùng phép chia **//**, ta sửa lại thành `p = n // q` được kết quả:
    
        ![image](https://hackmd.io/_uploads/H1XBRFB0p.png)

    - Sau bao nhiêu bão táp thì ta đã có được **p**, **q**, ta có thể dễ dàng giải được challenge này.
    - **Chú ý** là source code có dùng thư viện **Decimal**, thư viện này sẽ giúp bảo toàn giá trị của một số **Float** siêu nhỏ, vì khi python thấy một số **quá nhỏ** thì nó thường có xu hướng **làm tròn** số đó. Nhưng ở những bài toán cần sự chính xác cao thì ta nên dùng thư viện Decimal để python không làm tròn số siêu nhỏ đó:
        - k = 0.35446461146...51 là số siêu nhỏ nên dễ bị python làm tròn nên ta phải bỏ vào hàm Decimal('')

- Đoạn code sẽ như sau:
    ```python
    from Crypto.Util.number import *

    from decimal import *

    import gmpy2

    getcontext().prec = 1337 #cái này khá là quan trọng, giúp lấy 1337 số phía sau dấu phẩy

    n = 17836315959849005845422913663414767117290475262210084622418539759689446526987983742651500754163602658702257438603344638391750819833709014484652708660912517485982576088329107650903579302135534346444527279395069706657542682545893504177489484878621091879201295227306042107538374526455876591399833571819123247023786020228360607799594672502655951840534378236130046255384167067161776621232261217694793553143425503847220013445117355362394757758134988247473606426051594142031253234833680135858089993033130033931424522824906259429530883731507010765394295893181162700003958569803358503992193879775739289254856625735853342656691

    k = Decimal('0.35446461146963444739100675019102427357742992648252679674999337860249514861192798736714999768802138877188987392684434984434144197346204736005963436261945282663139698407968154340692664314828815899336950075608038792449489090135267728757601438063136872975188570457340429981256096772094559698810422884676267599207870407837622200963038727101881041482893243181001811673162760179737922603650432405683896302254608853145829174684136576632615125057461035561006166588616534081650626850782025114955080335366309301772569589757429270179660568900330573464408796713721197954022970442599587489433052980288173667649600013009228667427447792587021853498147264391918385888912849882116066995440393702466541549251997103552974697549782099608620829417323165099966257193351492516942787771855106373851382745426598388778335847224000662124245942956989214545858513358450753373387923120632015977747472238670285286237716130056230984986202065783225256225423691426735932011376256751926687386762108587816483740258699371757433615173305137434119292838712721416785355612250164642843800878962968768192098173866139532824196545174345900695673844077156572039278918984913397930317429787962557294721805738693054179811835717065028952910215615224680053236949692064119797385474426572790113251198730129280310478508674699026563792292928948060895646025882846864383863565586607209169223951')
    #kiểu dữ liệu float thường khá là lỗi do nó hay làm tròn nên ta sẽ dùng Decimal('') để giữ nguyên nó

    c = 4673035924389272278475077726179721834196795767239453119170003013692946332412255268083504867136759422845861665483227559383954843143670952281969970077731089347972838420010231661960479713394051608043031384693412159099965328507230965509961198520502268922686515047278411684052852995138615616040668732298091594792133478881624324818221814267947449074861355947381041272802241830653539106368971391423458933624515377831472054507217929993173878266225197776099109251511985341724790608910932841987840837417562296646705505719209341249852963919620413828831930283409960629361329433160615299527749956602571547705926320519915041473366

    e = 65537

    q2 = int((13*n)/(37*k))

    q = gmpy2.iroot(q2, 2)[0] #hàm tính căn promax

    p = n // q

    print(long_to_bytes(pow(c, pow(e, -1, (p-1)*(q-1)), n)))
    #kết quả sẽ là: b'W1{now_you_know_how_to_use_continued_fraction!}'
    ```
- Vậy flag của challenge này là: ***W1{now_you_know_how_to_use_continued_fraction!}***
    

